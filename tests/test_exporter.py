"""
Unit tests for the Exporter module.

Tests export functionality for various 3D formats including STL, OBJ, PLY, and GLTF.
"""

import unittest
import tempfile
import shutil
from pathlib import Path
from unittest.mock import Mock, patch, MagicMock
import numpy as np
import json

# Import the module to test
import sys
sys.path.append('..')
from exporter import Exporter, ExportError, ValidationError, get_supported_formats, validate_export_format


class TestExporter(unittest.TestCase):
    """Test cases for the Exporter class."""
    
    def setUp(self):
        """Set up test fixtures."""
        # Create temporary directory for test outputs
        self.temp_dir = Path(tempfile.mkdtemp())
        self.exporter = Exporter(output_dir=self.temp_dir)
        
        # Create test mesh data
        self.test_mesh = {
            'vertices': np.array([
                [0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 1.0, 0.0], [0.0, 1.0, 0.0],  # Bottom
                [0.0, 0.0, 1.0], [1.0, 0.0, 1.0], [1.0, 1.0, 1.0], [0.0, 1.0, 1.0]   # Top
            ]),
            'faces': [
                [0, 1, 2], [0, 2, 3],  # Bottom face
                [4, 7, 6], [4, 6, 5],  # Top face
                [0, 4, 5], [0, 5, 1],  # Front face
                [2, 6, 7], [2, 7, 3],  # Back face
                [0, 3, 7], [0, 7, 4],  # Left face
                [1, 5, 6], [1, 6, 2]   # Right face
            ],
            'normals': [
                (0, 0, -1), (0, 0, -1),  # Bottom
                (0, 0, 1), (0, 0, 1),    # Top
                (0, -1, 0), (0, -1, 0),  # Front
                (0, 1, 0), (0, 1, 0),    # Back
                (-1, 0, 0), (-1, 0, 0),  # Left
                (1, 0, 0), (1, 0, 0)     # Right
            ]
        }
        
        # Simple triangle mesh for basic tests
        self.simple_mesh = {
            'vertices': np.array([[0, 0, 0], [1, 0, 0], [0.5, 1, 0]]),
            'faces': [[0, 1, 2]],
            'normals': [(0, 0, 1)]
        }
    
    def tearDown(self):
        """Clean up test fixtures."""
        # Remove temporary directory
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_exporter_initialization(self):
        """Test Exporter initialization."""
        # Test with default output directory
        exporter = Exporter()
        self.assertTrue(exporter.output_dir.exists())
        
        # Test with custom output directory
        custom_dir = self.temp_dir / "custom"
        exporter = Exporter(output_dir=custom_dir)
        self.assertEqual(exporter.output_dir, custom_dir)
        self.assertTrue(custom_dir.exists())
        
        # Test default settings
        self.assertFalse(exporter.stl_ascii)
        self.assertTrue(exporter.obj_include_materials)
        self.assertFalse(exporter.ply_ascii)
        self.assertTrue(exporter.gltf_embed_textures)
    
    def test_mesh_validation(self):
        """Test mesh validation for export."""
        # Valid mesh should pass
        self.assertTrue(self.exporter._validate_mesh_for_export(self.test_mesh))
        
        # Test invalid mesh types
        with self.assertRaises(ValidationError):
            self.exporter._validate_mesh_for_export("not a dict")
        
        with self.assertRaises(ValidationError):
            self.exporter._validate_mesh_for_export({})
        
        with self.assertRaises(ValidationError):
            self.exporter._validate_mesh_for_export({'vertices': []})
        
        # Test empty mesh
        empty_mesh = {'vertices': [], 'faces': []}\n        with self.assertRaises(ValidationError):\n            self.exporter._validate_mesh_for_export(empty_mesh)\n        \n        # Test invalid vertices\n        invalid_vertices_mesh = {\n            'vertices': np.array([[1, 2]]),  # 2D instead of 3D\n            'faces': [[0]]\n        }\n        with self.assertRaises(ValidationError):\n            self.exporter._validate_mesh_for_export(invalid_vertices_mesh)\n        \n        # Test invalid vertex values\n        nan_mesh = {\n            'vertices': np.array([[np.nan, 0, 0], [1, 0, 0], [0, 1, 0]]),\n            'faces': [[0, 1, 2]]\n        }\n        with self.assertRaises(ValidationError):\n            self.exporter._validate_mesh_for_export(nan_mesh)\n        \n        # Test invalid faces\n        invalid_face_mesh = {\n            'vertices': np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0]]),\n            'faces': [[0, 1]]  # Face with less than 3 vertices\n        }\n        with self.assertRaises(ValidationError):\n            self.exporter._validate_mesh_for_export(invalid_face_mesh)\n        \n        # Test face with invalid vertex index\n        invalid_index_mesh = {\n            'vertices': np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0]]),\n            'faces': [[0, 1, 5]]  # Index 5 doesn't exist\n        }\n        with self.assertRaises(ValidationError):\n            self.exporter._validate_mesh_for_export(invalid_index_mesh)\n    \n    def test_scaling(self):\n        """Test mesh scaling functionality."""\n        # Test no scaling (scale = 1.0)\n        scaled_mesh = self.exporter._apply_scaling(self.simple_mesh, 1.0)\n        np.testing.assert_array_equal(scaled_mesh['vertices'], self.simple_mesh['vertices'])\n        \n        # Test 2x scaling\n        scaled_mesh = self.exporter._apply_scaling(self.simple_mesh, 2.0)\n        expected_vertices = self.simple_mesh['vertices'] * 2.0\n        np.testing.assert_array_equal(scaled_mesh['vertices'], expected_vertices)\n        \n        # Test invalid scale values\n        with self.assertRaises(ExportError):\n            self.exporter._apply_scaling(self.simple_mesh, 0)\n        \n        with self.assertRaises(ExportError):\n            self.exporter._apply_scaling(self.simple_mesh, -1)\n        \n        with self.assertRaises(ExportError):\n            self.exporter._apply_scaling(self.simple_mesh, \"invalid\")\n    \n    def test_export_mesh_unsupported_format(self):\n        """Test export with unsupported format."""\n        with self.assertRaises(ExportError):\n            self.exporter.export_mesh(self.simple_mesh, \"test\", \"INVALID_FORMAT\")\n    \n    @patch('exporter.stl_mesh')\n    def test_stl_export_with_numpy_stl(self, mock_stl_mesh):\n        \"\"\"Test STL export using numpy-stl library.\"\"\"\n        # Mock the stl_mesh module\n        mock_mesh_instance = Mock()\n        mock_stl_mesh.Mesh.return_value = mock_mesh_instance\n        mock_stl_mesh.Mode.ASCII = 'ascii'\n        mock_stl_mesh.Mode.BINARY = 'binary'\n        \n        # Test binary STL export\n        output_path = self.exporter.export_stl(self.simple_mesh, \"test_binary\")\n        \n        self.assertEqual(output_path.name, \"test_binary.stl\")\n        mock_mesh_instance.save.assert_called_once()\n        \n        # Test ASCII STL export\n        output_path = self.exporter.export_stl(self.simple_mesh, \"test_ascii\", ascii=True)\n        \n        self.assertEqual(output_path.name, \"test_ascii.stl\")\n    \n    def test_stl_export_manual(self):\n        \"\"\"Test manual STL export implementation.\"\"\"\n        with patch('exporter.stl_mesh', None), patch('exporter.trimesh', None):\n            # Test ASCII STL export\n            output_path = self.exporter.export_stl(self.simple_mesh, \"test_manual_ascii\", ascii=True)\n            \n            self.assertTrue(output_path.exists())\n            self.assertEqual(output_path.suffix, \".stl\")\n            \n            # Check file content\n            with open(output_path, 'r') as f:\n                content = f.read()\n                self.assertIn(\"solid exported_mesh\", content)\n                self.assertIn(\"endsolid exported_mesh\", content)\n                self.assertIn(\"facet normal\", content)\n                self.assertIn(\"vertex\", content)\n            \n            # Test binary STL export\n            output_path = self.exporter.export_stl(self.simple_mesh, \"test_manual_binary\", ascii=False)\n            \n            self.assertTrue(output_path.exists())\n            self.assertEqual(output_path.suffix, \".stl\")\n            \n            # Check file is binary (has correct header size)\n            with open(output_path, 'rb') as f:\n                header = f.read(80)\n                self.assertEqual(len(header), 80)\n    \n    @patch('exporter.trimesh')\n    def test_obj_export_with_trimesh(self, mock_trimesh):\n        \"\"\"Test OBJ export using trimesh library.\"\"\"\n        mock_mesh_instance = Mock()\n        mock_trimesh.Trimesh.return_value = mock_mesh_instance\n        \n        output_path = self.exporter.export_obj(self.simple_mesh, \"test_obj\")\n        \n        self.assertEqual(output_path.name, \"test_obj.obj\")\n        mock_mesh_instance.export.assert_called_once()\n    \n    def test_obj_export_manual(self):\n        \"\"\"Test manual OBJ export implementation.\"\"\"\n        with patch('exporter.trimesh', None):\n            # Test OBJ export with materials\n            output_path = self.exporter.export_obj(self.simple_mesh, \"test_manual_obj\", materials=True)\n            \n            self.assertTrue(output_path.exists())\n            self.assertEqual(output_path.suffix, \".obj\")\n            \n            # Check OBJ file content\n            with open(output_path, 'r') as f:\n                content = f.read()\n                self.assertIn(\"# OBJ file exported\", content)\n                self.assertIn(\"mtllib\", content)\n                self.assertIn(\"usemtl\", content)\n                self.assertIn(\"v \", content)  # Vertices\n                self.assertIn(\"f \", content)  # Faces\n            \n            # Check MTL file was created\n            mtl_path = output_path.with_suffix('.mtl')\n            self.assertTrue(mtl_path.exists())\n            \n            with open(mtl_path, 'r') as f:\n                mtl_content = f.read()\n                self.assertIn(\"newmtl\", mtl_content)\n                self.assertIn(\"Ka\", mtl_content)  # Ambient\n                self.assertIn(\"Kd\", mtl_content)  # Diffuse\n                self.assertIn(\"Ks\", mtl_content)  # Specular\n            \n            # Test OBJ export without materials\n            output_path = self.exporter.export_obj(self.simple_mesh, \"test_no_materials\", materials=False)\n            \n            with open(output_path, 'r') as f:\n                content = f.read()\n                self.assertNotIn(\"mtllib\", content)\n                self.assertNotIn(\"usemtl\", content)\n    \n    @patch('exporter.trimesh')\n    def test_ply_export_with_trimesh(self, mock_trimesh):\n        \"\"\"Test PLY export using trimesh library.\"\"\"\n        mock_mesh_instance = Mock()\n        mock_mesh_instance.visual = Mock()\n        mock_trimesh.Trimesh.return_value = mock_mesh_instance\n        \n        output_path = self.exporter.export_ply(self.simple_mesh, \"test_ply\")\n        \n        self.assertEqual(output_path.name, \"test_ply.ply\")\n        mock_mesh_instance.export.assert_called_once()\n    \n    def test_ply_export_manual(self):\n        \"\"\"Test manual PLY export implementation.\"\"\"\n        with patch('exporter.trimesh', None):\n            # Test ASCII PLY export\n            output_path = self.exporter.export_ply(self.simple_mesh, \"test_manual_ply\", ascii=True)\n            \n            self.assertTrue(output_path.exists())\n            self.assertEqual(output_path.suffix, \".ply\")\n            \n            # Check PLY file content\n            with open(output_path, 'r') as f:\n                content = f.read()\n                self.assertIn(\"ply\", content)\n                self.assertIn(\"format ascii 1.0\", content)\n                self.assertIn(\"element vertex\", content)\n                self.assertIn(\"element face\", content)\n                self.assertIn(\"end_header\", content)\n            \n            # Test binary PLY export\n            output_path = self.exporter.export_ply(self.simple_mesh, \"test_binary_ply\", ascii=False)\n            \n            self.assertTrue(output_path.exists())\n            \n            # Check binary PLY header\n            with open(output_path, 'rb') as f:\n                header = f.read(100).decode('ascii', errors='ignore')\n                self.assertIn(\"ply\", header)\n                self.assertIn(\"format binary_little_endian\", header)\n            \n            # Test PLY export with colors\n            colors = np.array([[255, 0, 0], [0, 255, 0], [0, 0, 255]])\n            output_path = self.exporter.export_ply(self.simple_mesh, \"test_colored_ply\", \n                                                 ascii=True, colors=colors)\n            \n            with open(output_path, 'r') as f:\n                content = f.read()\n                self.assertIn(\"property uchar red\", content)\n                self.assertIn(\"property uchar green\", content)\n                self.assertIn(\"property uchar blue\", content)\n    \n    @patch('exporter.trimesh')\n    def test_gltf_export_with_trimesh(self, mock_trimesh):\n        \"\"\"Test GLTF export using trimesh library.\"\"\"\n        mock_mesh_instance = Mock()\n        mock_trimesh.Trimesh.return_value = mock_mesh_instance\n        \n        output_path = self.exporter.export_gltf(self.simple_mesh, \"test_gltf\")\n        \n        self.assertEqual(output_path.name, \"test_gltf.gltf\")\n        mock_mesh_instance.export.assert_called_once()\n        \n        # Test binary GLTF\n        output_path = self.exporter.export_gltf(self.simple_mesh, \"test_glb\", binary=True)\n        self.assertEqual(output_path.name, \"test_glb.glb\")\n    \n    def test_gltf_export_manual(self):\n        \"\"\"Test manual GLTF export implementation.\"\"\"\n        with patch('exporter.trimesh', None):\n            # Test JSON GLTF export\n            output_path = self.exporter.export_gltf(self.simple_mesh, \"test_manual_gltf\")\n            \n            self.assertTrue(output_path.exists())\n            self.assertEqual(output_path.suffix, \".gltf\")\n            \n            # Check GLTF JSON content\n            with open(output_path, 'r') as f:\n                gltf_data = json.load(f)\n                self.assertIn(\"asset\", gltf_data)\n                self.assertIn(\"version\", gltf_data[\"asset\"])\n                self.assertIn(\"scenes\", gltf_data)\n                self.assertIn(\"nodes\", gltf_data)\n                self.assertIn(\"meshes\", gltf_data)\n                self.assertIn(\"accessors\", gltf_data)\n                self.assertIn(\"bufferViews\", gltf_data)\n                self.assertIn(\"buffers\", gltf_data)\n            \n            # Check binary buffer file was created\n            bin_path = output_path.with_suffix('.bin')\n            self.assertTrue(bin_path.exists())\n            \n            # Test binary GLTF (should raise error in manual mode)\n            with self.assertRaises(ExportError):\n                self.exporter.export_gltf(self.simple_mesh, \"test_binary_gltf\", binary=True)\n    \n    def test_file_validation(self):\n        \"\"\"Test export file validation.\"\"\"\n        # Create test files for validation\n        \n        # Valid ASCII STL\n        stl_path = self.temp_dir / \"test.stl\"\n        with open(stl_path, 'w') as f:\n            f.write(\"solid test\\n\")\n            f.write(\"  facet normal 0 0 1\\n\")\n            f.write(\"    outer loop\\n\")\n            f.write(\"      vertex 0 0 0\\n\")\n            f.write(\"      vertex 1 0 0\\n\")\n            f.write(\"      vertex 0 1 0\\n\")\n            f.write(\"    endloop\\n\")\n            f.write(\"  endfacet\\n\")\n            f.write(\"endsolid test\\n\")\n        \n        self.assertTrue(self.exporter.validate_export(stl_path, 'STL'))\n        \n        # Valid OBJ\n        obj_path = self.temp_dir / \"test.obj\"\n        with open(obj_path, 'w') as f:\n            f.write(\"v 0 0 0\\n\")\n            f.write(\"v 1 0 0\\n\")\n            f.write(\"v 0 1 0\\n\")\n            f.write(\"f 1 2 3\\n\")\n        \n        self.assertTrue(self.exporter.validate_export(obj_path, 'OBJ'))\n        \n        # Valid PLY\n        ply_path = self.temp_dir / \"test.ply\"\n        with open(ply_path, 'w') as f:\n            f.write(\"ply\\n\")\n            f.write(\"format ascii 1.0\\n\")\n            f.write(\"element vertex 3\\n\")\n            f.write(\"property float x\\n\")\n            f.write(\"property float y\\n\")\n            f.write(\"property float z\\n\")\n            f.write(\"element face 1\\n\")\n            f.write(\"property list uchar int vertex_indices\\n\")\n            f.write(\"end_header\\n\")\n            f.write(\"0 0 0\\n\")\n            f.write(\"1 0 0\\n\")\n            f.write(\"0 1 0\\n\")\n            f.write(\"3 0 1 2\\n\")\n        \n        self.assertTrue(self.exporter.validate_export(ply_path, 'PLY'))\n        \n        # Valid GLTF\n        gltf_path = self.temp_dir / \"test.gltf\"\n        gltf_data = {\n            \"asset\": {\"version\": \"2.0\"},\n            \"scenes\": [],\n            \"nodes\": [],\n            \"meshes\": []\n        }\n        with open(gltf_path, 'w') as f:\n            json.dump(gltf_data, f)\n        \n        self.assertTrue(self.exporter.validate_export(gltf_path, 'GLTF'))\n        \n        # Test validation errors\n        \n        # Non-existent file\n        with self.assertRaises(ValidationError):\n            self.exporter.validate_export(Path(\"nonexistent.stl\"), 'STL')\n        \n        # Empty file\n        empty_path = self.temp_dir / \"empty.stl\"\n        empty_path.touch()\n        with self.assertRaises(ValidationError):\n            self.exporter.validate_export(empty_path, 'STL')\n        \n        # Invalid STL\n        invalid_stl = self.temp_dir / \"invalid.stl\"\n        with open(invalid_stl, 'w') as f:\n            f.write(\"invalid content\")\n        with self.assertRaises(ValidationError):\n            self.exporter.validate_export(invalid_stl, 'STL')\n        \n        # Invalid OBJ (no vertices)\n        invalid_obj = self.temp_dir / \"invalid.obj\"\n        with open(invalid_obj, 'w') as f:\n            f.write(\"# comment only\")\n        with self.assertRaises(ValidationError):\n            self.exporter.validate_export(invalid_obj, 'OBJ')\n        \n        # Invalid PLY\n        invalid_ply = self.temp_dir / \"invalid.ply\"\n        with open(invalid_ply, 'w') as f:\n            f.write(\"not a ply file\")\n        with self.assertRaises(ValidationError):\n            self.exporter.validate_export(invalid_ply, 'PLY')\n        \n        # Invalid GLTF (no asset)\n        invalid_gltf = self.temp_dir / \"invalid.gltf\"\n        with open(invalid_gltf, 'w') as f:\n            json.dump({\"invalid\": \"data\"}, f)\n        with self.assertRaises(ValidationError):\n            self.exporter.validate_export(invalid_gltf, 'GLTF')\n    \n    def test_get_export_info(self):\n        \"\"\"Test export file information retrieval.\"\"\"\n        # Create a test file\n        test_path = self.temp_dir / \"test.stl\"\n        with open(test_path, 'w') as f:\n            f.write(\"test content\")\n        \n        info = self.exporter.get_export_info(test_path)\n        \n        self.assertEqual(info[\"file_path\"], str(test_path))\n        self.assertEqual(info[\"format\"], \"STL\")\n        self.assertGreater(info[\"file_size\"], 0)\n        self.assertIn(\"created\", info)\n        self.assertIn(\"modified\", info)\n        \n        # Test non-existent file\n        info = self.exporter.get_export_info(Path(\"nonexistent.stl\"))\n        self.assertIn(\"error\", info)\n    \n    @patch('exporter.trimesh')\n    def test_create_trimesh_object(self, mock_trimesh):\n        \"\"\"Test trimesh object creation.\"\"\"\n        mock_mesh_instance = Mock()\n        mock_trimesh.Trimesh.return_value = mock_mesh_instance\n        \n        vertices = self.simple_mesh['vertices']\n        faces = self.simple_mesh['faces']\n        \n        result = self.exporter._create_trimesh_object(vertices, faces)\n        \n        self.assertEqual(result, mock_mesh_instance)\n        mock_trimesh.Trimesh.assert_called_once()\n        \n        # Test with quad faces (should be split into triangles)\n        quad_faces = [[0, 1, 2, 3]]\n        self.exporter._create_trimesh_object(vertices, quad_faces)\n        \n        # Verify trimesh was called with triangulated faces\n        call_args = mock_trimesh.Trimesh.call_args\n        passed_faces = call_args[1]['faces']\n        # Quad should be split into 2 triangles\n        self.assertEqual(len(passed_faces), 2)\n    \n    def test_create_trimesh_object_without_trimesh(self):\n        \"\"\"Test trimesh object creation when trimesh is not available.\"\"\"\n        with patch('exporter.trimesh', None):\n            with self.assertRaises(ExportError):\n                self.exporter._create_trimesh_object(self.simple_mesh['vertices'], \n                                                   self.simple_mesh['faces'])\n    \n    def test_export_mesh_integration(self):\n        \"\"\"Test complete export mesh workflow.\"\"\"\n        # Test successful export\n        with patch('exporter.trimesh', None), patch('exporter.stl_mesh', None):\n            output_path = self.exporter.export_mesh(self.simple_mesh, \"integration_test\", \"STL\", \n                                                   ascii=True, scale=2.0)\n            \n            self.assertTrue(output_path.exists())\n            self.assertEqual(output_path.name, \"integration_test.stl\")\n            \n            # Verify scaling was applied by checking file content\n            with open(output_path, 'r') as f:\n                content = f.read()\n                # Original vertex at (1, 0, 0) should be scaled to (2, 0, 0)\n                self.assertIn(\"vertex 2\", content)\n        \n        # Test export with invalid mesh\n        invalid_mesh = {'vertices': [], 'faces': []}\n        with self.assertRaises(ValidationError):\n            self.exporter.export_mesh(invalid_mesh, \"invalid\", \"STL\")\n\n\nclass TestUtilityFunctions(unittest.TestCase):\n    \"\"\"Test utility functions.\"\"\"\n    \n    def test_get_supported_formats(self):\n        \"\"\"Test getting supported export formats.\"\"\"\n        formats = get_supported_formats()\n        self.assertIsInstance(formats, list)\n        self.assertIn('STL', formats)\n        self.assertIn('OBJ', formats)\n        self.assertIn('PLY', formats)\n        self.assertIn('GLTF', formats)\n    \n    def test_validate_export_format(self):\n        \"\"\"Test export format validation.\"\"\"\n        # Valid formats\n        self.assertTrue(validate_export_format('STL'))\n        self.assertTrue(validate_export_format('stl'))  # Case insensitive\n        self.assertTrue(validate_export_format('OBJ'))\n        self.assertTrue(validate_export_format('PLY'))\n        self.assertTrue(validate_export_format('GLTF'))\n        \n        # Invalid formats\n        self.assertFalse(validate_export_format('INVALID'))\n        self.assertFalse(validate_export_format('3DS'))\n        self.assertFalse(validate_export_format(''))\n\n\nif __name__ == '__main__':\n    # Run the tests\n    unittest.main(verbosity=2)