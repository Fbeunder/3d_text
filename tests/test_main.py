"""
Unit tests for main application module.

Tests the main application interface, CLI parsing, workflow orchestration,
and integration of all core modules.
"""

import unittest
from unittest.mock import Mock, patch, MagicMock, call
import tempfile
import shutil
from pathlib import Path
import argparse
import sys
import io

# Import the module under test
import main
from main import (
    Text3DGenerator, create_argument_parser, validate_arguments,
    generate_output_path, print_processing_stats, setup_application_logging,
    Text3DGeneratorError, WorkflowError
)

# Import exceptions for testing
from text_processor import FontLoadError, TextProcessingError
from geometry_generator import GeometryError, MeshValidationError
from renderer import RenderingError
from exporter import ExportError


class TestText3DGenerator(unittest.TestCase):
    """Test the main Text3DGenerator class."""
    
    def setUp(self):
        """Set up test fixtures."""
        self.temp_dir = Path(tempfile.mkdtemp())
        self.config_overrides = {'DEFAULT_OUTPUT_DIR': self.temp_dir}
        
        # Create mock components
        self.mock_font_loader = Mock()
        self.mock_text_processor = Mock()
        self.mock_geometry_generator = Mock()
        self.mock_renderer = Mock()
        self.mock_exporter = Mock()
        
        # Patch the imports to use mocks
        self.patches = [
            patch('main.FontLoader', return_value=self.mock_font_loader),
            patch('main.TextProcessor', return_value=self.mock_text_processor),
            patch('main.GeometryGenerator', return_value=self.mock_geometry_generator),
            patch('main.Renderer', return_value=self.mock_renderer),
            patch('main.Exporter', return_value=self.mock_exporter),
        ]
        
        for p in self.patches:
            p.start()
        
        self.generator = Text3DGenerator(self.config_overrides)
    
    def tearDown(self):
        """Clean up test fixtures."""
        # Stop all patches
        for p in self.patches:
            p.stop()
        
        # Clean up temp directory
        if self.temp_dir.exists():
            shutil.rmtree(self.temp_dir)
    
    def test_initialization(self):
        """Test generator initialization."""
        self.assertIsNotNone(self.generator.font_loader)
        self.assertIsNotNone(self.generator.text_processor)
        self.assertIsNotNone(self.generator.geometry_generator)
        self.assertIsNotNone(self.generator.renderer)
        self.assertIsNotNone(self.generator.exporter)
        
        self.assertEqual(self.generator.config_overrides, self.config_overrides)
        self.assertIsNone(self.generator.current_text)
        self.assertIsNone(self.generator.current_mesh)
        self.assertEqual(self.generator.processing_stats, {})\n    
    @patch('main.validate_file_path')\n    def test_load_font_success(self, mock_validate):\n        \"\"\"Test successful font loading.\"\"\"\n        mock_validate.return_value = True\n        self.mock_font_loader.load_font.return_value = True\n        \n        result = self.generator.load_font('/path/to/font.ttf', 72)\n        \n        self.assertTrue(result)\n        self.mock_font_loader.load_font.assert_called_once_with('/path/to/font.ttf', 72)\n        self.assertEqual(self.generator.processing_stats['font_path'], '/path/to/font.ttf')\n        self.assertEqual(self.generator.processing_stats['font_size'], 72)\n    \n    @patch('main.validate_file_path')\n    @patch('main.Config')\n    def test_load_font_fallback_to_default(self, mock_config_class, mock_validate):\n        \"\"\"Test font loading with fallback to default font.\"\"\"\n        mock_validate.return_value = False\n        mock_config = Mock()\n        mock_config.get_default_font_path.return_value = Path('/system/font.ttf')\n        mock_config_class.return_value = mock_config\n        \n        # Re-create generator with mocked config\n        generator = Text3DGenerator()\n        generator.config = mock_config\n        generator.font_loader = self.mock_font_loader\n        \n        self.mock_font_loader.load_font.return_value = True\n        \n        result = generator.load_font('/invalid/path.ttf')\n        \n        self.assertTrue(result)\n        self.mock_font_loader.load_font.assert_called_once()\n    \n    def test_load_font_invalid_size(self):\n        \"\"\"Test font loading with invalid size.\"\"\"\n        with patch('main.Config') as mock_config_class:\n            mock_config = Mock()\n            mock_config.validate_font_size.return_value = False\n            mock_config_class.return_value = mock_config\n            \n            generator = Text3DGenerator()\n            generator.config = mock_config\n            \n            with self.assertRaises(FontLoadError):\n                generator.load_font('/path/to/font.ttf', 1000)\n    \n    def test_process_text_success(self):\n        \"\"\"Test successful text processing.\"\"\"\n        self.mock_text_processor.parse_text.return_value = \"Hello\"\n        self.mock_text_processor.calculate_layout.return_value = [\n            {'character': 'H', 'position': (0, 0), 'width': 10},\n            {'character': 'e', 'position': (12, 0), 'width': 8},\n        ]\n        self.mock_text_processor.get_text_outlines.return_value = {\n            'H': [[(0, 0), (10, 0), (10, 20), (0, 20)]],\n            'e': [[(0, 0), (8, 0), (8, 15), (0, 15)]]\n        }\n        \n        result = self.generator.process_text(\"Hello\", 2.0)\n        \n        self.assertEqual(result['text'], \"Hello\")\n        self.assertEqual(result['character_count'], 2)\n        self.assertEqual(result['total_width'], 20)\n        \n        self.mock_text_processor.parse_text.assert_called_once_with(\"Hello\")\n        self.mock_text_processor.calculate_layout.assert_called_once_with(\"Hello\", 2.0)\n    \n    def test_process_text_empty(self):\n        \"\"\"Test text processing with empty text.\"\"\"\n        with self.assertRaises(TextProcessingError):\n            self.generator.process_text(\"\")\n        \n        with self.assertRaises(TextProcessingError):\n            self.generator.process_text(\"   \")\n    \n    def test_generate_geometry_success(self):\n        \"\"\"Test successful geometry generation.\"\"\"\n        text_data = {\n            'outlines': {\n                'A': [[(0, 0), (10, 0), (5, 20)]]\n            },\n            'layout': [\n                {'character': 'A', 'position': (0, 0)}\n            ]\n        }\n        \n        mock_mesh = {\n            'vertices': [(0, 0, 0), (10, 0, 0), (5, 20, 0), (0, 0, 5), (10, 0, 5), (5, 20, 5)],\n            'faces': [[0, 1, 2], [3, 5, 4]],\n            'normals': [(0, 0, -1), (0, 0, 1)]\n        }\n        \n        self.mock_geometry_generator.generate_mesh.return_value = mock_mesh\n        \n        result = self.generator.generate_geometry(text_data, 5.0, 1.0)\n        \n        self.assertEqual(result['character_meshes'], 1)\n        self.assertEqual(result['total_vertices'], 6)\n        self.assertEqual(result['total_faces'], 2)\n        self.assertIn('bounds', result)\n        \n        self.mock_geometry_generator.generate_mesh.assert_called_once()\n    \n    def test_generate_geometry_no_outlines(self):\n        \"\"\"Test geometry generation with no outlines.\"\"\"\n        text_data = {'outlines': {}, 'layout': []}\n        \n        with self.assertRaises(GeometryError):\n            self.generator.generate_geometry(text_data)\n    \n    def test_generate_geometry_invalid_depth(self):\n        \"\"\"Test geometry generation with invalid depth.\"\"\"\n        text_data = {'outlines': {'A': []}, 'layout': []}\n        \n        with patch('main.Config') as mock_config_class:\n            mock_config = Mock()\n            mock_config.validate_extrusion_depth.return_value = False\n            mock_config_class.return_value = mock_config\n            \n            generator = Text3DGenerator()\n            generator.config = mock_config\n            \n            with self.assertRaises(GeometryError):\n                generator.generate_geometry(text_data, -1.0)\n    \n    def test_render_preview_success(self):\n        \"\"\"Test successful preview rendering.\"\"\"\n        geometry_data = {\n            'mesh': {'vertices': [], 'faces': []},\n            'bounds': {'size': (10, 10, 5)}\n        }\n        \n        self.mock_renderer.render_to_image.return_value = '/path/to/preview.png'\n        \n        result = self.generator.render_preview(geometry_data, '/output/preview.png')\n        \n        self.assertEqual(result, '/path/to/preview.png')\n        self.mock_renderer.render_to_image.assert_called_once()\n    \n    def test_render_preview_no_mesh(self):\n        \"\"\"Test preview rendering with no mesh data.\"\"\"\n        geometry_data = {}\n        \n        with self.assertRaises(RenderingError):\n            self.generator.render_preview(geometry_data)\n    \n    @patch('main.ensure_directory_exists')\n    @patch('main.safe_filename')\n    @patch('main.get_unique_filename')\n    def test_export_model_success(self, mock_unique, mock_safe, mock_ensure):\n        \"\"\"Test successful model export.\"\"\"\n        geometry_data = {\n            'mesh': {'vertices': [], 'faces': []}\n        }\n        \n        mock_safe.return_value = 'test_model'\n        mock_unique.return_value = Path('/output/test_model.stl')\n        self.mock_exporter.export_mesh.return_value = '/output/test_model.stl'\n        \n        with patch('main.Config') as mock_config_class:\n            mock_config = Mock()\n            mock_config.validate_export_format.return_value = True\n            mock_config_class.return_value = mock_config\n            \n            generator = Text3DGenerator()\n            generator.config = mock_config\n            generator.exporter = self.mock_exporter\n            \n            result = generator.export_model(geometry_data, '/output/test.stl', 'STL')\n            \n            self.assertEqual(result, '/output/test_model.stl')\n            self.mock_exporter.export_mesh.assert_called_once()\n    \n    def test_export_model_invalid_format(self):\n        \"\"\"Test model export with invalid format.\"\"\"\n        geometry_data = {'mesh': {}}\n        \n        with patch('main.Config') as mock_config_class:\n            mock_config = Mock()\n            mock_config.validate_export_format.return_value = False\n            mock_config_class.return_value = mock_config\n            \n            generator = Text3DGenerator()\n            generator.config = mock_config\n            \n            with self.assertRaises(ExportError):\n                generator.export_model(geometry_data, '/output/test.xyz', 'XYZ')\n    \n    @patch('main.time')\n    def test_run_workflow_complete(self, mock_time):\n        \"\"\"Test complete workflow execution.\"\"\"\n        mock_time.time.side_effect = [0, 10]  # Start and end times\n        \n        # Setup mocks for successful workflow\n        self.mock_font_loader.load_font.return_value = True\n        self.mock_text_processor.parse_text.return_value = \"Test\"\n        self.mock_text_processor.calculate_layout.return_value = [\n            {'character': 'T', 'position': (0, 0), 'width': 10}\n        ]\n        self.mock_text_processor.get_text_outlines.return_value = {\n            'T': [[(0, 0), (10, 0), (10, 20), (0, 20)]]\n        }\n        \n        mock_mesh = {\n            'vertices': [(0, 0, 0), (10, 0, 0)],\n            'faces': [[0, 1, 2]],\n            'normals': [(0, 0, 1)]\n        }\n        self.mock_geometry_generator.generate_mesh.return_value = mock_mesh\n        self.mock_exporter.export_mesh.return_value = '/output/test.stl'\n        \n        with patch('main.Config') as mock_config_class:\n            mock_config = Mock()\n            mock_config.validate_extrusion_depth.return_value = True\n            mock_config.validate_export_format.return_value = True\n            mock_config_class.return_value = mock_config\n            \n            generator = Text3DGenerator()\n            generator.font_loader = self.mock_font_loader\n            generator.text_processor = self.mock_text_processor\n            generator.geometry_generator = self.mock_geometry_generator\n            generator.exporter = self.mock_exporter\n            generator.config = mock_config\n            \n            result = generator.run_workflow(\n                \"Test\",\n                font_path=\"/font.ttf\",\n                output_path=\"/output/test.stl\",\n                export_format=\"STL\"\n            )\n            \n            self.assertIn('text_processing', result)\n            self.assertIn('geometry_generation', result)\n            self.assertIn('exported_path', result)\n            self.assertIn('processing_stats', result)\n            self.assertEqual(result['processing_stats']['total_time'], 10)\n    \n    def test_reset(self):\n        \"\"\"Test generator state reset.\"\"\"\n        # Set some state\n        self.generator.current_text = \"Test\"\n        self.generator.current_mesh = {}\n        self.generator.processing_stats = {'test': 'data'}\n        \n        # Reset\n        self.generator.reset()\n        \n        # Verify state is cleared\n        self.assertIsNone(self.generator.current_text)\n        self.assertIsNone(self.generator.current_mesh)\n        self.assertEqual(self.generator.processing_stats, {})\n    \n    def test_combine_meshes_single(self):\n        \"\"\"Test combining a single mesh.\"\"\"\n        mesh = {'vertices': [(0, 0, 0)], 'faces': [[0, 1, 2]], 'normals': [(0, 0, 1)]}\n        \n        result = self.generator._combine_meshes([mesh])\n        \n        self.assertEqual(result, mesh)\n    \n    def test_combine_meshes_multiple(self):\n        \"\"\"Test combining multiple meshes.\"\"\"\n        mesh1 = {\n            'vertices': [(0, 0, 0), (1, 0, 0)],\n            'faces': [[0, 1, 2]],\n            'normals': [(0, 0, 1)]\n        }\n        mesh2 = {\n            'vertices': [(2, 0, 0), (3, 0, 0)],\n            'faces': [[0, 1, 2]],\n            'normals': [(0, 0, 1)]\n        }\n        \n        self.mock_geometry_generator.calculate_normals.return_value = [(0, 0, 1), (0, 0, 1)]\n        \n        result = self.generator._combine_meshes([mesh1, mesh2])\n        \n        self.assertEqual(len(result['vertices']), 4)\n        self.assertEqual(len(result['faces']), 2)\n        self.assertEqual(result['faces'][1], [2, 3, 4])  # Offset applied\n    \n    def test_combine_meshes_empty(self):\n        \"\"\"Test combining empty mesh list.\"\"\"\n        with self.assertRaises(GeometryError):\n            self.generator._combine_meshes([])\n    \n    def test_calculate_mesh_bounds(self):\n        \"\"\"Test mesh bounds calculation.\"\"\"\n        mesh = {\n            'vertices': [(0, 0, 0), (10, 5, 3), (-2, 8, 1)]\n        }\n        \n        bounds = self.generator._calculate_mesh_bounds(mesh)\n        \n        self.assertEqual(bounds['min'], (-2, 0, 0))\n        self.assertEqual(bounds['max'], (10, 8, 3))\n        self.assertEqual(bounds['size'], (12, 8, 3))\n    \n    def test_calculate_mesh_bounds_empty(self):\n        \"\"\"Test mesh bounds calculation with empty mesh.\"\"\"\n        mesh = {'vertices': []}\n        \n        bounds = self.generator._calculate_mesh_bounds(mesh)\n        \n        self.assertEqual(bounds['min'], (0, 0, 0))\n        self.assertEqual(bounds['max'], (0, 0, 0))\n        self.assertEqual(bounds['size'], (0, 0, 0))\n\n\nclass TestArgumentParser(unittest.TestCase):\n    \"\"\"Test command-line argument parsing.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        self.parser = create_argument_parser()\n    \n    def test_required_arguments(self):\n        \"\"\"Test parsing of required arguments.\"\"\"\n        args = self.parser.parse_args(['\"Hello World\"'])\n        \n        self.assertEqual(args.text, '\"Hello World\"')\n    \n    def test_font_options(self):\n        \"\"\"Test parsing of font options.\"\"\"\n        args = self.parser.parse_args([\n            'Test',\n            '--font', '/path/to/font.ttf',\n            '--font-size', '48',\n            '--character-spacing', '1.5'\n        ])\n        \n        self.assertEqual(args.font, '/path/to/font.ttf')\n        self.assertEqual(args.font_size, 48)\n        self.assertEqual(args.character_spacing, 1.5)\n    \n    def test_geometry_options(self):\n        \"\"\"Test parsing of 3D geometry options.\"\"\"\n        args = self.parser.parse_args([\n            'Test',\n            '--depth', '10.5',\n            '--bevel', '2.0',\n            '--bevel-resolution', '8'\n        ])\n        \n        self.assertEqual(args.depth, 10.5)\n        self.assertEqual(args.bevel, 2.0)\n        self.assertEqual(args.bevel_resolution, 8)\n    \n    def test_export_options(self):\n        \"\"\"Test parsing of export options.\"\"\"\n        args = self.parser.parse_args([\n            'Test',\n            '--output', '/output/test.obj',\n            '--format', 'OBJ',\n            '--export-scale', '2.0',\n            '--output-dir', '/custom/output'\n        ])\n        \n        self.assertEqual(args.output, '/output/test.obj')\n        self.assertEqual(args.format, 'OBJ')\n        self.assertEqual(args.export_scale, 2.0)\n        self.assertEqual(args.output_dir, '/custom/output')\n    \n    def test_preview_options(self):\n        \"\"\"Test parsing of preview options.\"\"\"\n        args = self.parser.parse_args([\n            'Test',\n            '--preview',\n            '--save-preview', '/preview.png'\n        ])\n        \n        self.assertTrue(args.preview)\n        self.assertEqual(args.save_preview, '/preview.png')\n    \n    def test_output_options(self):\n        \"\"\"Test parsing of output options.\"\"\"\n        args = self.parser.parse_args([\n            'Test',\n            '--verbose',\n            '--stats',\n            '--log-file', '/log.txt'\n        ])\n        \n        self.assertTrue(args.verbose)\n        self.assertTrue(args.stats)\n        self.assertEqual(args.log_file, '/log.txt')\n    \n    def test_quiet_option(self):\n        \"\"\"Test quiet option parsing.\"\"\"\n        args = self.parser.parse_args(['Test', '--quiet'])\n        \n        self.assertTrue(args.quiet)\n    \n    def test_short_options(self):\n        \"\"\"Test short option aliases.\"\"\"\n        args = self.parser.parse_args([\n            'Test',\n            '-f', 'font.ttf',\n            '-d', '5.0',\n            '-b', '1.0',\n            '-o', 'output.stl',\n            '-v'\n        ])\n        \n        self.assertEqual(args.font, 'font.ttf')\n        self.assertEqual(args.depth, 5.0)\n        self.assertEqual(args.bevel, 1.0)\n        self.assertEqual(args.output, 'output.stl')\n        self.assertTrue(args.verbose)\n\n\nclass TestArgumentValidation(unittest.TestCase):\n    \"\"\"Test command-line argument validation.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        self.valid_args = argparse.Namespace(\n            text=\"Test\",\n            font_size=72,\n            depth=5.0,\n            bevel=1.0,\n            font=None\n        )\n    \n    @patch('main.Config')\n    def test_validate_arguments_success(self, mock_config_class):\n        \"\"\"Test successful argument validation.\"\"\"\n        mock_config = Mock()\n        mock_config.validate_font_size.return_value = True\n        mock_config.validate_extrusion_depth.return_value = True\n        mock_config.MAX_TEXT_LENGTH = 1000\n        mock_config_class.return_value = mock_config\n        \n        # Should not raise any exception\n        validate_arguments(self.valid_args)\n    \n    @patch('main.Config')\n    def test_validate_font_size_invalid(self, mock_config_class):\n        \"\"\"Test validation with invalid font size.\"\"\"\n        mock_config = Mock()\n        mock_config.validate_font_size.return_value = False\n        mock_config_class.return_value = mock_config\n        \n        with self.assertRaises(ValueError) as cm:\n            validate_arguments(self.valid_args)\n        \n        self.assertIn(\"Font size must be between\", str(cm.exception))\n    \n    @patch('main.Config')\n    def test_validate_extrusion_depth_invalid(self, mock_config_class):\n        \"\"\"Test validation with invalid extrusion depth.\"\"\"\n        mock_config = Mock()\n        mock_config.validate_font_size.return_value = True\n        mock_config.validate_extrusion_depth.return_value = False\n        mock_config_class.return_value = mock_config\n        \n        with self.assertRaises(ValueError) as cm:\n            validate_arguments(self.valid_args)\n        \n        self.assertIn(\"Extrusion depth must be between\", str(cm.exception))\n    \n    @patch('main.Config')\n    def test_validate_bevel_depth_negative(self, mock_config_class):\n        \"\"\"Test validation with negative bevel depth.\"\"\"\n        mock_config = Mock()\n        mock_config.validate_font_size.return_value = True\n        mock_config.validate_extrusion_depth.return_value = True\n        mock_config_class.return_value = mock_config\n        \n        self.valid_args.bevel = -1.0\n        \n        with self.assertRaises(ValueError) as cm:\n            validate_arguments(self.valid_args)\n        \n        self.assertIn(\"Bevel depth cannot be negative\", str(cm.exception))\n    \n    @patch('main.Config')\n    def test_validate_bevel_depth_too_large(self, mock_config_class):\n        \"\"\"Test validation with bevel depth >= extrusion depth.\"\"\"\n        mock_config = Mock()\n        mock_config.validate_font_size.return_value = True\n        mock_config.validate_extrusion_depth.return_value = True\n        mock_config_class.return_value = mock_config\n        \n        self.valid_args.bevel = 6.0  # Greater than depth (5.0)\n        \n        with self.assertRaises(ValueError) as cm:\n            validate_arguments(self.valid_args)\n        \n        self.assertIn(\"Bevel depth must be less than extrusion depth\", str(cm.exception))\n    \n    @patch('main.validate_file_path')\n    @patch('main.Config')\n    def test_validate_font_file_invalid(self, mock_config_class, mock_validate):\n        \"\"\"Test validation with invalid font file.\"\"\"\n        mock_config = Mock()\n        mock_config.validate_font_size.return_value = True\n        mock_config.validate_extrusion_depth.return_value = True\n        mock_config_class.return_value = mock_config\n        \n        mock_validate.return_value = False\n        self.valid_args.font = '/invalid/font.ttf'\n        \n        with self.assertRaises(ValueError) as cm:\n            validate_arguments(self.valid_args)\n        \n        self.assertIn(\"Font file not found\", str(cm.exception))\n    \n    @patch('main.Config')\n    def test_validate_text_too_long(self, mock_config_class):\n        \"\"\"Test validation with text that's too long.\"\"\"\n        mock_config = Mock()\n        mock_config.validate_font_size.return_value = True\n        mock_config.validate_extrusion_depth.return_value = True\n        mock_config.MAX_TEXT_LENGTH = 10\n        mock_config_class.return_value = mock_config\n        \n        self.valid_args.text = \"This text is way too long for the limit\"\n        \n        with self.assertRaises(ValueError) as cm:\n            validate_arguments(self.valid_args)\n        \n        self.assertIn(\"Text too long\", str(cm.exception))\n\n\nclass TestUtilityFunctions(unittest.TestCase):\n    \"\"\"Test utility functions.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        self.temp_dir = Path(tempfile.mkdtemp())\n    \n    def tearDown(self):\n        \"\"\"Clean up test fixtures.\"\"\"\n        if self.temp_dir.exists():\n            shutil.rmtree(self.temp_dir)\n    \n    @patch('main.safe_filename')\n    @patch('main.ensure_directory_exists')\n    @patch('main.get_unique_filename')\n    def test_generate_output_path(self, mock_unique, mock_ensure, mock_safe):\n        \"\"\"Test output path generation.\"\"\"\n        mock_safe.return_value = \"hello_world\"\n        mock_unique.return_value = Path(\"/output/hello_world.stl\")\n        \n        result = generate_output_path(\"Hello World!\", \"/output\", \"STL\")\n        \n        self.assertEqual(result, \"/output/hello_world.stl\")\n        mock_safe.assert_called_once_with(\"Hello World!\")\n        mock_ensure.assert_called_once()\n        mock_unique.assert_called_once()\n    \n    @patch('main.safe_filename')\n    @patch('main.ensure_directory_exists')\n    @patch('main.get_unique_filename')\n    def test_generate_output_path_gltf(self, mock_unique, mock_ensure, mock_safe):\n        \"\"\"Test output path generation for GLTF format.\"\"\"\n        mock_safe.return_value = \"test\"\n        mock_unique.return_value = Path(\"/output/test.glb\")\n        \n        result = generate_output_path(\"Test\", \"/output\", \"GLTF\")\n        \n        # Should use .glb extension for GLTF\n        mock_unique.assert_called_once_with(Path(\"/output\"), \"test\", \"glb\")\n    \n    @patch('main.safe_filename')\n    @patch('main.ensure_directory_exists')\n    @patch('main.get_unique_filename')\n    def test_generate_output_path_empty_text(self, mock_unique, mock_ensure, mock_safe):\n        \"\"\"Test output path generation with empty safe filename.\"\"\"\n        mock_safe.return_value = \"\"\n        mock_unique.return_value = Path(\"/output/text_3d.stl\")\n        \n        result = generate_output_path(\"!!!\", \"/output\", \"STL\")\n        \n        mock_unique.assert_called_once_with(Path(\"/output\"), \"text_3d\", \"stl\")\n    \n    def test_print_processing_stats(self):\n        \"\"\"Test processing statistics printing.\"\"\"\n        stats = {\n            'font_path': '/font.ttf',\n            'font_size': 72,\n            'character_count': 5,\n            'total_width': 50.0,\n            'vertices': 100,\n            'faces': 50,\n            'extrusion_depth': 5.0,\n            'bevel_depth': 1.0,\n            'export_format': 'STL',\n            'export_path': '/output.stl',\n            'total_time': 2.5\n        }\n        \n        # Capture stdout\n        captured_output = io.StringIO()\n        sys.stdout = captured_output\n        \n        try:\n            print_processing_stats(stats)\n            output = captured_output.getvalue()\n            \n            self.assertIn(\"PROCESSING STATISTICS\", output)\n            self.assertIn(\"/font.ttf\", output)\n            self.assertIn(\"Characters: 5\", output)\n            self.assertIn(\"100 vertices\", output)\n            self.assertIn(\"2.5 seconds\", output)\n        finally:\n            sys.stdout = sys.__stdout__\n    \n    @patch('main.setup_logging')\n    def test_setup_application_logging_verbose(self, mock_setup):\n        \"\"\"Test logging setup in verbose mode.\"\"\"\n        args = argparse.Namespace(verbose=True, quiet=False, log_file=None)\n        \n        setup_application_logging(args)\n        \n        mock_setup.assert_called_once_with('DEBUG', None)\n    \n    @patch('main.setup_logging')\n    def test_setup_application_logging_quiet(self, mock_setup):\n        \"\"\"Test logging setup in quiet mode.\"\"\"\n        args = argparse.Namespace(verbose=False, quiet=True, log_file=None)\n        \n        setup_application_logging(args)\n        \n        mock_setup.assert_called_once_with('ERROR', None)\n    \n    @patch('main.setup_logging')\n    def test_setup_application_logging_with_file(self, mock_setup):\n        \"\"\"Test logging setup with log file.\"\"\"\n        args = argparse.Namespace(verbose=False, quiet=False, log_file='/log.txt')\n        \n        setup_application_logging(args)\n        \n        mock_setup.assert_called_once_with('INFO', Path('/log.txt'))\n\n\nclass TestMainFunction(unittest.TestCase):\n    \"\"\"Test the main function.\"\"\"\n    \n    @patch('main.Text3DGenerator')\n    @patch('main.create_argument_parser')\n    @patch('main.setup_application_logging')\n    @patch('main.validate_arguments')\n    @patch('main.generate_output_path')\n    def test_main_success(self, mock_generate_path, mock_validate, mock_setup_logging,\n                         mock_parser_func, mock_generator_class):\n        \"\"\"Test successful main function execution.\"\"\"\n        # Setup mocks\n        mock_args = Mock()\n        mock_args.text = \"Test\"\n        mock_args.font = None\n        mock_args.output = None\n        mock_args.preview = False\n        mock_args.quiet = False\n        mock_args.stats = False\n        mock_args.verbose = False\n        mock_args.format = \"STL\"\n        mock_args.output_dir = None\n        \n        mock_parser = Mock()\n        mock_parser.parse_args.return_value = mock_args\n        mock_parser_func.return_value = mock_parser\n        \n        mock_generator = Mock()\n        mock_generator.run_workflow.return_value = {\n            'exported_path': '/output/test.stl',\n            'processing_stats': {}\n        }\n        mock_generator_class.return_value = mock_generator\n        \n        mock_generate_path.return_value = '/output/test.stl'\n        \n        # Capture stdout\n        captured_output = io.StringIO()\n        sys.stdout = captured_output\n        \n        try:\n            result = main.main()\n            \n            self.assertEqual(result, 0)\n            mock_validate.assert_called_once_with(mock_args)\n            mock_generator.run_workflow.assert_called_once()\n            \n            output = captured_output.getvalue()\n            self.assertIn(\"completed successfully\", output)\n        finally:\n            sys.stdout = sys.__stdout__\n    \n    @patch('main.create_argument_parser')\n    def test_main_keyboard_interrupt(self, mock_parser_func):\n        \"\"\"Test main function with keyboard interrupt.\"\"\"\n        mock_parser = Mock()\n        mock_parser.parse_args.side_effect = KeyboardInterrupt()\n        mock_parser_func.return_value = mock_parser\n        \n        # Capture stdout\n        captured_output = io.StringIO()\n        sys.stdout = captured_output\n        \n        try:\n            result = main.main()\n            \n            self.assertEqual(result, 1)\n            output = captured_output.getvalue()\n            self.assertIn(\"cancelled by user\", output)\n        finally:\n            sys.stdout = sys.__stdout__\n    \n    @patch('main.create_argument_parser')\n    @patch('main.setup_application_logging')\n    @patch('main.validate_arguments')\n    def test_main_exception(self, mock_validate, mock_setup_logging, mock_parser_func):\n        \"\"\"Test main function with exception.\"\"\"\n        mock_args = Mock()\n        mock_args.verbose = False\n        \n        mock_parser = Mock()\n        mock_parser.parse_args.return_value = mock_args\n        mock_parser_func.return_value = mock_parser\n        \n        mock_validate.side_effect = ValueError(\"Test error\")\n        \n        result = main.main()\n        \n        self.assertEqual(result, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()